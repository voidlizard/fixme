## 2023-03-29

FIXME: raspberrypi-error
  При поптыке запустить `fixme update` или `fixme list` на Raspberry Pi 4
  программа завершается и ничего не выводит.
  Таблицы fixme и blob в state.db при этом пустые.

## 2023-03-23

Moved to hbs2://D6xVrGwrjATM8u5v1NEbra2aneWaggPqbgbWj9MHXFqA

FIXME: proper-last-log-detection

TODO: segmented-log-processing
 1. Обрабатывать все лог в порядке коммитов для блоба лога
 2. Обрабатывать diff текущего лога (что бы отображать незакоммиченные изменения)


## 2023-03-01

TODO: seek-fixme-state-in-upper-level-directories
  Искать .fixme выше по дереву, но но выше, чем
  ближайший .git

## 2023-02-28

TODO: macro-command
  Сделать макрокоманды, так, что бы можно было, например
  вместо

  ```
  fixme set workflow backlog XXXX
  ```
  делать
  ```
  fixme backlog XXXX
  ```


## 2023-02-26

TODO: fixme-set-attribute
 Сделать атрибут с множественным значением ( Set Text / List Text ).
 Примеры, когда нужно:

  - теги
  - оценка задачи от разных участников


## 2023-02-25

TODO: fixme-update-before-report
  Делать fixme update автоматически перед report/list,
  запоминать некий тег или хэш (лог+конфиг+значение всех голов
  репозитория), что бы не делать fixme update повторно.

TODO: attributes-specific-for-tag
  Сделать атрибуты, специфичные для конкретного
  тега.

  Тогда, если у атрибута не задан тег, считается,
  что атрибут существует для всех тегов.

  Если у атрибута задан тег, то этот атрибут присутствует
  только у этого тега.

  Тогда: ключом атрибута являтся Maybe Tag.

  Пример: атрибут version только для тега CHANGE:

## 2023-02-22

TODO: print-fixme-version-from-cabal

TODO: generate-gitignore-by-default
 Generate .gitignore file with
 "state.db" in .fixme/config by default (fixme init)


## 2023-02-19


TODO: move-attributes-on-merge
  При merge все атрибуты старого fixme
  должны переезжать в новый fixme
  ```
   update fixmeattr set id = :new-fixme-id where id = :old-fixme-id
  ```


TODO: log-play-optimization-3
  Ввести операцию trim над логом. Операция trim
  очищает лог, и первой командой лога ставит fixme-log-prev
  предыдущего лога. Для каждого "текущего" лога такая команда
  должна быть одна / уникальная.

  Тогда, при проигрывании журнала - мы сначала извлекаем
  fixme-log-prev,  из лога по хэшу --- извлекаем предыдущий
  и так далее, строим цепочку блоков (может быть тоже оптимизировано),
  реверсируем цепочку и скипаем блоки в начале, помеченные, как
  processed, далее проигрываем журналы и помечаем их в processed.



## 2023-02-15

FIXME: end-of-todo-line-marker
  to not read block comments closing characters

FIXME: default-config-does-not-work


## 2023-02-14

TODO: progress-bar-on-blob-scanning


## 2023-02-12

TODO: rework-list-to-user-reports

TODO: fixme-meta-commiters-command

TODO: limit-blob-scanning-depth

  use --since or other way to limit
  scanning in order to make it work
  faster on older projects.

## 2023-02-10

TODO: attribute-value-limitations-to-config

  Возможно задавать ограничения на названия атрибутов
  и их значения. #easy


TODO: default-context-for-cat

  ```
  fixme-default-context 2 10
  ```


TODO: set-attribute-from-context
  like commit-time, commit-date and so on.

TODO: set-attribute-from-issue-itself

  Парсить тело fixme, доставать оттуда атрибуты
  и устанавливать их (как?) при выполнении fix scan.


TODO: log-play-optimization-proposal-2
  Делаем merke дерево файла с разбиением по строкам (важно).
  Сохраняем листья в базе. Для каждого листа запоминаем, исполнялся
  он или нет.

  Проверить, может быть, вставка в начале не поменяет
  последующие блоки (хотя решается ссылкой на предыдущий
  блок в последующем.

  Если не редактировать начало файла, то блоки повторно
  исполняться не будут.

  Можно поступать проше и исполнять только диф лога с последним
  запомненным, но тогда если кто-то отредактирует начало, то всё
  придёт в неконсистенное состояние.


TODO: log-play-optimization-proposal
  Для каждой позиции лога считаем то, что было до неё.
  Считаем хэш текущей позиции. Считаем hash(prev,current).
  Исполняем. Записываем в state это значение. В следующий
  раз смотрим, если такое значение существует, значит, эта
  команда для этого контекста уже выполнялась.


TODO: failed-fixme-end-detection

  see FMPweN6dmPysM7qAS62rnK2VwQWnn3exTvoqdXmFAwXK


TODO: fixme-authors-command
  Implement a command that will show all authors
  from all commits from the repo.

  Should not process commits twice.

  1. List all commits
  2. Parse authors
  3. Save authors to a specific table
  4. Save the commit hash


TODO: merge-to-null-to-hide-fixmie

TODO: inverted-filters

TODO: exact-attrib-filters


TODO: dont-show-already-existed-fixmies-in-scan

  Не показывать fixme в scan, если они уже есть в кэше
  #easy

TODO: define-how-to-process-log

  Что бы писать в fixmeattrlog что-то релевантное (хэш самого файла? хэш коммита?)
  нужно определить политику, что туда писать.

  Допустим, это хэш самого файла. Тогда можно его произвольно менять до коммита,
  запускать fixme scan, он будет менять атрибуты, потом еще раз поменять
  лог и закоммитить.

  В итоге, rev в fixmeattrlog будет ссылаться на несуществующий в гите объект.

  Как с этим бороться пока не очень понятно.

  Можно принудительно читать только закоммиченный лог. Тогда это будет
  вызывать удивление -- т.к текущее состояние в рабочей копии будет
  игнорироваться.


## 2023-02-09

TODO: skip-empty-fixmies

  ignore empty fixme entries


TODO: test-uuid
 $(uuid ce6655b5-840c-4ddd-9916-0909ed921c48)

 Рандомный uuid делает любой fixme уникальным


TODO: fixme-uuid-command

  Сделать команду

  ```
  fixme uuid
  ```

  которая будет генерировать uuid  в виде строки uuid: <UUID>
  которую можно будет вставлять в fixme и обеспечивать тем самым
  его уникальность.

  wtf?


## 2023-02-08

TODO:  fixme-from-git-rev-list
 На самом деле, нужно не парсить файлы проекта по маске,
 а получать список объектов текущего дерева из
 ```
   git ls-tree -r master
 ```
 например. Тогда объекты будут гарантированно закоммичены,
 и не нужно будет озадачиваться вопросом, что делать, если
 id  у fixme есть, а контента нет (после коммита).

 Маска, впрочем, всё равно нужна --- что бы фильтровать файлы,
 которые использовать. filepattern будет работать в любом случае
 (хорошо!).


TODO:  fixme track command
  Делает так, что бы fixme становился постоянным и начинал отслеживаться.
  Как это сделать? Пока непонятно #tbd

FIXME: inline-fixmies-ignored
  Сейчас игнорируются fixmies, которые находятся в одной
  строке с кодом.

  Можно так и оставить, т.к. это создаёт много неоднозначностей.
  В конце концов, каждый такой fixme можно переписать так,
  что бы он соответствовал текущим соглашениям.


## 2023-02-07

Итак, приступим

FIXME: стрипать только indent пробелов,
  а то форматирование ломается.

TODO:  определить формат хранения статусов
   Варианты:
     1.  Просто в файле, текстовый лог изменений.
         Тогда будет шум в дифах. Можно сделать
         лог бинарным (с добавлением строго в конец),
         тогда не будет показывать в дифах, а просто,
         что файл изменён. Если сделать так, что бы
         файл писался строго в конец, то будет работать.

         Оценка:

           (-5) Кто угодно может перезаписать и все к
                черту покорраптится

           (+1) Можно откатить к предыдущей версии

           (+1) Просто

     2. Одна операция (серия операций) --- один
        git объект.

        Оценка:

           (+1) Файл в репозитории, что бы найти и поломать
                требуются специальные усилия и тогда
                поменяется его хэш.

           (+1) Не будет шума в логах

           (-2) Требуются специальные усилия, что бы эти
                объекты синхронизировались:

                Нужно создавать tree object, commit object.
                В узлы tree object прописывать файлы изменений.

                Прописывать результат в специальный ref.

                Самим пушить этот ref.


TODO: вычислять id для fixme

  Определить, что является id для fixme. Это может быть,
  например, хэш от ключевой информации -- хэш файла+позиция
  + какая-то соль, возможно. Нужно, что бы у всех были
  одинаковые ID, что наводит на мысль, что это должно быть
  hash(hash(blob)+position).

  С одной стороны, это достаточно однозначный идентификатор,
  который в случае использования git будет у всех одинаковый
  для данной версии файла.

  С другой стороны --- он длинный, что неудобно.

  С третьей стороны --- можно выводить префикс определенной
  длины и обрабатывать коллизии. Как делают в гите.

  Наверное, это наш путь, особенно, если брать достаточно
  длинный префикс в base58.


TODO: читать весь FIXME, не только заголовок

TODO: считать хэши для каждого FIXME

TODO: идентацию для каждого FIXME

FIXME:  найти файлы по маске

FIXME: найти все вхождения для fixme в найденных
  файлах, имея в виду следующий формат:

  ```
  identation comment space+ tag space space* char char* eol
  (identation comment space+ char* eol)+
  eol | identation /= fixme.identation
  ```


